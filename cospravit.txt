Start eventu:
1. ak je uz event v timeline, cize uz bezi
   - odmaze sa - toto zaisti, ze ak event znovaspustim (co je dovolene), tak mevzniknnu duplikaty eventu v timeline
   - ak je event prvy v timeline
     - TOTO JE CELE ZLE
	   - poposuvaju sa _fkProfileEndActivated po timeline smerom k prvemu (???)
	   - po poposuvani ma prvy event v timeline _fkProfileEndActivated nastaveny na _fkProfileStart vymazaneho eventu
	     takze treba nastavit fkProfileEndActivated na _fkProfileEndActivated vymazaneho eventu
     - MA SA SPRAVIT
       - nic neposuvame, len updatneme end profile prveho na ten, co ho mal ten odmazany 
   - ak je event v strede timeline - TOTO JE NOVE
     - nic neposuvame, len updatneme end profile toho co bol za vymazanym na start profil eventu pred nim 
   - ak je event na konci timeline
     - netreba robit nic
2. ak je prvy v timeline
   - do timeline sa da do _fkProfileEndActivated prave aktivovany profil
2. ak uz v timeline nieco je
   - do timeline sa da do _fkProfileEndActivated _fkProfileStart posledneho eventu v timeline
3. event sa proda na koniec timeline

End eventu:
1. ak je uz event v timeline, cize uz bezi, odmaze sa 
   - ak je event prvy v timeline
     - TOTO JE CELE ZLE
	   - poposuvaju sa _fkProfileEndActivated po timeline smerom k prvemu (???)
	   - po poposuvani ma prvy event v timeline _fkProfileEndActivated nastaveny na _fkProfileStart vymazaneho eventu
	     takze treba nastavit fkProfileEndActivated na _fkProfileEndActivated vymazaneho eventu
     - MA SA SPRAVIT
       - nic neposuvame, len updatneme end profile prveho na ten, co ho mal ten odmazany 
   - ak je event v strede timeline - TOTO JE NOVE
     - nic neposuvame, len updatneme end profile toho co bol za vymazanym na start profil eventu pred nim 
   - ak je event na konci timeline
     - netreba robit nic
2. aktivujeme _fkProfileEndActivated eventu, co skoncil, ale len ak je na konci timeline


--------------------------------------------------------------------------

Vymazavanie eventu z timeline:

P0  - E1 P1 P0, E2 P2 P1, E3 P3 P2, E4 P4 P3
P0  -           E2 P2 P1, E3 P3 P2, E4 P4 P3
-------------------------------------------- 
P0  -           E2 P2 P0, E3 P3 P2, E4 P4 P3 - nic neposuvame, len updatneme end profile prveho na ten, co ho mal ten odmazany
P0  -           E2 P2 P0, E3 P3 P1, E4 P4 P2 - po starom, cele zle!!!
============================================
P0  - E1 P1 P0, E2 P2 P1, E3 P3 P2, E4 P4 P3
P0  - E1 P1 P0,         , E3 P3 P2, E4 P4 P3
--------------------------------------------
P0  - E1 P1 P0,         , E3 P3 P1, E4 P4 P3 - nic neposuvame, len updatneme end profile toho co bol za vymazanym na start profil eventu pred nim
============================================
P0  - E1 P1 P0, E2 P2 P1, E3 P3 P2, E4 P4 P3
P0  - E1 P1 P0, E2 P2 P1, E3 P3 P2,         
--------------------------------------------
P0  - E1 P1 P0, E2 P2 P1, E3 P3 P2,          - nic nerobime

----------------------------------------------------------------------------

Bluetooth

Pravdepodobne budeme musiet rozlisovat bluetooth profile:

Primo zisiti, aky profil je pripojeny sa da len pre 
A2DP        = Advanced Audio Distribution
HEADSET     = Headset
HEALTH      = Health Thermometer 

Toto nejde zistit, ci je pripojene. Zjavne to tu funguje inac
GATT        = Bluetooth Low Energy
GATT_SERVER = Bluetooth Low Energy

Spravme to tak, ze cez broadcast receiver si zistim, co sa pripojilo/odpojilo.
Na toto uz mam receiver BluetoothConnectionBroadcastReceiver.
Ten mi bude ukladat zariadenia, ktore sa pripojili.
Bude to List<BluetoothDevice>. 
Ak sa pripoji, pohladam jeho adresu v liste a ak tam nie je, pridame do listu.
List inicializujeme pri prvom starte aplikacie. 
!!! Tu moze byt problem, ze nedostanem pri starte ak prave bude nieco pripojene. !!!

Potom spravime scanner. Na to uz mam receiver BluetoothScanAlarmBroadcastReceiver. 
Ten bude vyuzivat zoznam pripojenych zariadeni z receivera BluetoothConnectionBroadcastReceiver.
Scanner bude scanovat bluetooth zariadenia.
Ak scanujeme zariadenie, ktore uz je v zozname pripojenych, nezapnemam scan. Ako pri Wifi.
Na scanovanie este treba spravit receiver na prijem najdeneho zariadenia.
Aj tu budeme ukladat zoznam do scanResults.
Tu je problem v tom, ze tu nedostavame naraz cely zoznam, ale postupne jedno zariadenie za druhym.
Cize treba vymysliet mechanizmus dvoch zoznamov. 
Jeden bude temporary, ktory sa vymaze na zaciatku scanu a postupne sa bude naplnat.
Druhy sa po ukonceni scanu naplni tym temporary a tenot sa bude pouzivat podobne ako scanResult pri Wifi.


Ak sa odpoji, pohladam jeho adresu a ak tam je, vymazem ho z listu.

------------------------------------

Location

1. Pouzijem GooglePlayService (GPSrv) - GeofenceDetection
2. Geofence je vlastne GPS suradnica + polomer
3. Geogence sa do GPSrv registrovava a odregistrovava
4. Na (de)registraciu je potrebny BroadcastReceiver 
   ---- toto naimplementujem do EventPreferencesFragmentu/aktivity alebo do custom DialogPreference

        // Create a new broadcast receiver to receive updates from the listeners and service
        mBroadcastReceiver = new GeofenceSampleReceiver();

        // Create an intent filter for the broadcast receiver
        mIntentFilter = new IntentFilter();

        // Action for broadcast Intents that report successful addition of geofences
        mIntentFilter.addAction(GeofenceUtils.ACTION_GEOFENCES_ADDED);

        // Action for broadcast Intents that report successful removal of geofences
        mIntentFilter.addAction(GeofenceUtils.ACTION_GEOFENCES_REMOVED);

        // Action for broadcast Intents containing various types of geofencing errors
        mIntentFilter.addAction(GeofenceUtils.ACTION_GEOFENCE_ERROR);

        // All Location Services sample apps use this category
        mIntentFilter.addCategory(GeofenceUtils.CATEGORY_LOCATION_SERVICES);

        // Register the broadcast receiver to receive status updates
        LocalBroadcastManager.getInstance(this).registerReceiver(mBroadcastReceiver, mIntentFilter);

    /**
     * Define a Broadcast receiver that receives updates from connection listeners and
     * the geofence transition service.
     */
    public class GeofenceSampleReceiver extends BroadcastReceiver {
        /*
         * Define the required method for broadcast receivers
         * This method is invoked when a broadcast Intent triggers the receiver
         */
        @Override
        public void onReceive(Context context, Intent intent) {

            // Check the action code and determine what to do
            String action = intent.getAction();

            // Intent contains information about errors in adding or removing geofences
            if (TextUtils.equals(action, GeofenceUtils.ACTION_GEOFENCE_ERROR)) {

                handleGeofenceError(context, intent);

            // Intent contains information about successful addition or removal of geofences
            } else if (
                    TextUtils.equals(action, GeofenceUtils.ACTION_GEOFENCES_ADDED)
                    ||
                    TextUtils.equals(action, GeofenceUtils.ACTION_GEOFENCES_REMOVED)) {

                handleGeofenceStatus(context, intent);

            // Intent contains information about a geofence transition
            } else if (TextUtils.equals(action, GeofenceUtils.ACTION_GEOFENCE_TRANSITION)) {

                handleGeofenceTransition(context, intent);

            // The Intent contained an invalid action
            } else {
                Log.e(GeofenceUtils.APPTAG, getString(R.string.invalid_action_detail, action));
                Toast.makeText(context, R.string.invalid_action, Toast.LENGTH_LONG).show();
            }
        }

        /**
         * If you want to display a UI message about adding or removing geofences, put it here.
         *
         * @param context A Context for this component
         * @param intent The received broadcast Intent
         */
        private void handleGeofenceStatus(Context context, Intent intent) {

        }

        /**
         * Report geofence transitions to the UI
         *
         * @param context A Context for this component
         * @param intent The Intent containing the transition
         */
        private void handleGeofenceTransition(Context context, Intent intent) {
            /*
             * If you want to change the UI when a transition occurs, put the code
             * here. The current design of the app uses a notification to inform the
             * user that a transition has occurred.
             */
        }

        /**
         * Report addition or removal errors to the UI, using a Toast
         *
         * @param intent A broadcast Intent sent by ReceiveTransitionsIntentService
         */
        private void handleGeofenceError(Context context, Intent intent) {
            String msg = intent.getStringExtra(GeofenceUtils.EXTRA_GEOFENCE_STATUS);
            Log.e(GeofenceUtils.APPTAG, msg);
            Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
        }
    }

5. Treba testnut, ci ma uzivatel nainstalovany GPServ
   ---- toto budem musiet spravit na boot zariadenia. Problem je, ze je treba aktivitu na to, dokonca FragmentActivity.
   		Mozno to vyriesim vytvorenim empty aktivity.

    /**
     * Verify that Google Play services is available before making a request.
     *
     * @return true if Google Play services is available, otherwise false
     */
    private boolean servicesConnected() {

        // Check that Google Play services is available
        int resultCode =
                GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);

        // If Google Play services is available
        if (ConnectionResult.SUCCESS == resultCode) {

            // In debug mode, log the status
            Log.d(GeofenceUtils.APPTAG, getString(R.string.play_services_available));

            // Continue
            return true;

        // Google Play services was not available for some reason
        } else {

            // Display an error dialog
            Dialog dialog = GooglePlayServicesUtil.getErrorDialog(resultCode, this, 0);
            if (dialog != null) {
                ErrorDialogFragment errorFragment = new ErrorDialogFragment();
                errorFragment.setDialog(dialog);
                errorFragment.show(getSupportFragmentManager(), GeofenceUtils.APPTAG);
            }
            return false;
        }
    }

    /**
     * Define a DialogFragment to display the error dialog generated in
     * showErrorDialog.
     */
    public static class ErrorDialogFragment extends DialogFragment {

        // Global field to contain the error dialog
        private Dialog mDialog;

        /**
         * Default constructor. Sets the dialog field to null
         */
        public ErrorDialogFragment() {
            super();
            mDialog = null;
        }

        /**
         * Set the dialog to display
         *
         * @param dialog An error dialog
         */
        public void setDialog(Dialog dialog) {
            mDialog = dialog;
        }

        /*
         * This method must return a Dialog to the DialogFragment.
         */
        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            return mDialog;
        }
    }

6. Na samotne zaregistrovanie geofences pouzi class GeofenceRequester z prikladovej aplikacie GeofenceDetection.
   - Pridanie listu geofences sa robi metodou addGeofences(); 
7. Na zrusenie geofences pouzi class GeofenceRemover z prikladovej aplikacie GeofenceDetection
   - Vymazanie podmnoziny geofences sa robi metodou removeGeofencesById()
   - Vymazanie vsetkcy geofences sa robi metodou removeGeofencesByIntent() - asi rychlejsie ako prva metoda, ktorou sa to da tiez
9. Moze sa stat, ze sa vyvolaju dialogy z GPServ (!!!), tak treba, aby aktivita z ktorej volam add/remove geofences obsahovala
   metodu onActivityResult
   ---- toto fakt netusim, ako vyriesim, ked budem nahadzovat geofences z boot receivera a z EventPreferencesActivity (???)
      
    /*
     * Handle results returned to this Activity by other Activities started with
     * startActivityForResult(). In particular, the method onConnectionFailed() in
     * GeofenceRemover and GeofenceRequester may call startResolutionForResult() to
     * start an Activity that handles Google Play services problems. The result of this
     * call returns here, to onActivityResult.
     * calls
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        // Choose what to do based on the request code
        switch (requestCode) {

            // If the request code matches the code sent in onConnectionFailed
            case GeofenceUtils.CONNECTION_FAILURE_RESOLUTION_REQUEST :

                switch (resultCode) {
                    // If Google Play services resolved the problem
                    case Activity.RESULT_OK:

                        // If the request was to add geofences
                        if (GeofenceUtils.REQUEST_TYPE.ADD == mRequestType) {

                            // Toggle the request flag and send a new request
                            mGeofenceRequester.setInProgressFlag(false);

                            // Restart the process of adding the current geofences
                            mGeofenceRequester.addGeofences(mCurrentGeofences);

                        // If the request was to remove geofences
                        } else if (GeofenceUtils.REQUEST_TYPE.REMOVE == mRequestType ){

                            // Toggle the removal flag and send a new removal request
                            mGeofenceRemover.setInProgressFlag(false);

                            // If the removal was by Intent
                            if (GeofenceUtils.REMOVE_TYPE.INTENT == mRemoveType) {

                                // Restart the removal of all geofences for the PendingIntent
                                mGeofenceRemover.removeGeofencesByIntent(
                                    mGeofenceRequester.getRequestPendingIntent());

                            // If the removal was by a List of geofence IDs
                            } else {

                                // Restart the removal of the geofence list
                                mGeofenceRemover.removeGeofencesById(mGeofenceIdsToRemove);
                            }
                        }
                    break;

                    // If any other result was returned by Google Play services
                    default:

                        // Report that Google Play services was unable to resolve the problem.
                        Log.d(GeofenceUtils.APPTAG, getString(R.string.no_resolution));
                }

            // If any other request code was received
            default:
               // Report that this Activity received an unknown requestCode
               Log.d(GeofenceUtils.APPTAG,
                       getString(R.string.unknown_activity_request_code, requestCode));

               break;
        }
    }
   
10. GeofenceRequester a GeofenceRemover registruju IntentService, ktory sa bude volat vzdy, ak akualna lokacia je v nejakom
    geofence. 
	Ide o class ReceiveTransitionsIntentService z prikladovej aplikacie GeofenceDetection.
----------
Co som zistil:
1. GeofenceSampleReceiver - nie je treba lebo:
   a) ACTION_GEOFENCE_ERROR - toto sa da vyriesit osetrenim chyb v
      - ReceiveTransitionsIntentService
      - GeofenceRequester 	    
      - GeofenceRemover
   b) ACTION_GEOFENCES_ADDED - toto sa da vyriesit osetrenim v
      - GeofenceRequester
   c) ACTION_GEOFENCES_REMOVED - toto sa da vyriesit osetrenim v
      - GeofenceRemover
   d) ACTION_GEOFENCE_TRANSITION - toto sa da vyriesit osetrenim v 
      - ReceiveTransitionsIntentService
2. Problem je stale z onActivityResult. Z GeofenceRequester a GeofenceRemover je volane toto:
   
     /*
         * Google Play services can resolve some errors it detects.
         * If the error has a resolution, try sending an Intent to
         * start a Google Play services activity that can resolve
         * error.
         */
        if (connectionResult.hasResolution()) {

            try {
                // Start an Activity that tries to resolve the error
                connectionResult.startResolutionForResult(mActivity,
                    GeofenceUtils.CONNECTION_FAILURE_RESOLUTION_REQUEST);

            /*
             * Thrown if Google Play services canceled the original
             * PendingIntent
             */
            } catch (SendIntentException e) {
                // Log the error
                e.printStackTrace();
            }
       }
   
   Toto je potrebne, lebo inac nebudem vediet uzivatelovi zobrazit error dialog, ked sa nieco stane interne v GPSrv.
   Problem je, ze je treba aktivitu ako parameter na to.
   Mozno to vyriesim vytvorenim empty aktivity.
-----
Stale nemam vyriesene ako zadavat tie geofences   
1. Spravim predsa len dialog s mapkou s My Location layer
2. Pod mapou bude seekbar na urcenie radiusu pre geofence 
3. Pod seekbarom bude Edit text, ktorym moze pomenovat polohu na mape. Polou ziskam:
   - zistenim aktualnej polohy - ak kliknem na My Location button - je na to tl. listener
   - ak kliknem niekde na mape - je na to listener  
4. Vedla EditTextu bude button na pridanie geofence a jeho update.
5. Pod Edit textom bude compobox (spinner) so aktualnou polohou a vsetkymi geofences, ktore kedy uzivatel zadal. 
   Cize nemazat geofences ak zmazem event. Uzivatel vyberie zo spinnera 1 lokaciu. Ak uzivatel vyberie lokaciu
   nastavi sa na nu mapa, aj Edit text sa nastavi na jeho meno.
6. Vedla comboboxu bude button na vymazanie geofenze, ktory je prave zobrazeny.

-------------------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled

zen_mode ==== !!!!! TOTO JE ONO A FUNGUJE TO !!!
Len je problem, vyzaduje to root :-/ Hadam to Google opravi a ringer modom sa to bude dat menit, alebo daju dake ine api na to.
0 -> ALL      - mode_ringer = 2  
1 -> Priority - mode_ringer = 2
2 -> NONE     - mode_ringer = 0

----------------------------------------

Wifi/bluetooth scanning
1. WifiScanAlarmBroadcastReceiver:
	a) kuknut, ci je pripojene ku wifi (tak ako to je teraz)
	b) ak nie je, zavolat service na scan 
2. service na scan
    a) kuknut state, ako je to v WifiScanAlarmBroadcastReceiver
    b) spustit scan alebo nastavit, aby sa scanovalo, tak ako to je v WifiScanAlarmBroadcastReceiver
    c) v cykle cakat na getStartScan, tak ko to je v WifiSSIDPreference
    d) po cykle nastavit vsetko na false
3. WifiScanBroadcastReceiver nemenit
4. WifiConnectionBroadcastReceiver nemenit
5. WifiStateChangedBroadcastReceiver nemenit
6. WifiSSIDPreference
    a) povolit wifi ak je treba
    b) netestovat, ci uz scanning bezi
    c) nastavit setForceOneWifiScan()
    d) zavolat scanning, ktory vola service a cakat ako teraz
    e) cakat na ukoncenie scanningu ako teraz
    f) nenastavovat scanning shared preferences
   
-----------------------------------------------

Ringer mode:

ring             - ringer_mode=normal, zen_mode=all, volume>0
   1. set ringer_mode - set zen_mode=all
   2. set_volumes     - set vibrate when volume=0
   3. set ringer_mode - set zen_mode=all, when volume=0 set volume=1
ring and vibrate - ringer_mode=normal, zen_mode=all, volume>0, vibrate for calls
   1. set ringer_mode - set zen_mode=all, vibrate for call
   2. set_volumes     - set vibrate, when volume=0
   3. set ringer_mode - set zen_mode=all, when volume=0 sets volume=1
vibrate          - ringer_mode=vibrate, zen_mode=all, volume=0, vibrate for calls
   1. set ringer_mode - set zen_mode=all, vibrate for call
   2. set_volumes     - reset vibrate when volume>0
   3. set ringer_mode - set zen_mode=all, set volume=0
silent           - ringer_mode=silent, zen_mode=priority, volume=0
   1. set ringer_mode - set zen_mode=priority, vibrate for call
   2. set_volumes     - set vibrate, when volume=0
   3. set ringer_mode - set zen_mode=priority, reset vibrate, volume can not by changed!!!

OK, co tak pre Android 5.0 spravit zen mode:
1. Do "Mod zvonenia/vybrovania" pridat "Do not disturb" mod ("Nevyrusovat") (zen mode)
2. Ten pridat dynamicky ak je Android 5.0
3. Pri importe, aj je tento mod v db, zmenit na mod "Silent"
4. Pridat novy ListPreference pre zen mode ("Do not disturb type").
5. Ten bude enablovany len ak je vybraty  zen mod
6. Zen mod sa da nastavovat len na rootnutych zariadeniach.
7. Cize ak nie je root, "Do not disturb type" bude disablovany
       
--------------------

Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)

----------------------

Activity log:
- spravit tabulku, do ktrej budeme logovat aktivitu:
- typ aktivity:
  1. aktivaciu profilu
  2. ukoncenie trvania aktivacie profilu - nerobit nic
  2. ukoncenie trvania aktivacie profilu - vratit spat profil
  2. ukoncenie trvania aktivacie profilu - aktivovat predvoleny profil
  2. ukoncenie trvania aktivacie profilu - restartovat udalosti
  3. start eventu
  4. start eventu po delay
  5. end eventu - nerobit nic
  5. end eventu - aktivovat profil
  5. end eventu - vratit spat profil
  5. end eventu - aktivovat profil a vratit spat profil
  6. restart eventov
  7. globalny stop eventov
  8. globalny start eventov
  9. start aplikacie
  10. exit aplikacie
  11. import dat
- v zazname bude:
  1. datum a cas
  2. typ aktivity - vid vyssie
  3. nazov udalosti - udalost ktora sa startla/pauzla
  4. resource_id ikony profilu
  5. nazov profilu - nazov profilu, ktory sa aktivoval - tu dame nazov tak ako pri notifikacii (profil [udalost])
  6. trvanie/delay
- budeme drzat maximalne tyzden stare zaznamy

---------------------------

povolenie/zakazanie vybrovania pri dotyku: Settings.System.HAPTIC_FEEDBACK_ENABLED (0,1)

---------------------------

Pridanie priznaku pristupnosti do kalendar event nastaveni

String	AVAILABILITY	If this event counts as busy time or is still free time that can be scheduled over.
int	AVAILABILITY_BUSY	Indicates that this event takes up time and will conflict with other events.
int	AVAILABILITY_FREE	Indicates that this event is free time and will not conflict with other events.
int	AVAILABILITY_TENTATIVE	Indicates that the owner's availability may change, but should be considered busy time that will conflict.

Toto je INTEGER polozka, cize sa tu neda pouzit vyhladavanie retazca.
Preto navrhujem prerobit EventPreferencesCalendar

	public String _calendars;
	public String _titleString;         // EditText
	public String _descriptionString;   // EditText
	public String _locationString;      // EditText
	public int _availabilityType;       // listselector

Medzi jednotlivymi polozkami bude AND

----------------------------------------------

Co sa deje ked konci udalost

1. rusi sa Delay alarm - uz nema vyznam, lebo sa event pauzuje
2. odblokuje sa event, ak bol forceRun event bloknuty manualnou aktivaciou profilu - uz nesmie byt
   bloknuty, aby sa pri dalsom spustani aj spustil
3. event sa odmazava z timeline listu - v timeline liste maju byt len beziace eventy
4. nastavi sa system event pre dalsi start eventu
5. updatne sa status eventu v db (status PAUSE)
6. zaloguje sa do Activity logu, ze sa event pauzuje
7. hlada sa v eventtimeline liste, ci este bezia dake forcerun eventy a ak nebezia, nastavi sa
   shared preference PREF_FORCE_RUN_EVENT_RUNNING na false
8. ak event bezal, aktivuje sa End profile podla parametrov eventu

Ako sa aktivuje profil, ked event startuje
1. profil sa aktivuje, len ak este nie je aktivovany
2. je mozna vynimka, ak je parameter reactivate true, tak sa aktivuje vzdy
3. ak sa neaktivoval profil v bodoch 1 a 2, updatne sa notifikacia a widgety na aktualne aktivovany
   profil
Vysledkom je, ze sa nic nezmeni (ak je reactivate false), zostane aktivovane to, co prave aktivovane
je. Cize event profile nedeaktivuje.
Aj ak sa prida moznost zadat, ze sa nema nic aktivovat (bude nutne pre event type "Profile"),
tak sa nic nedeaktivuje.

Ako sa aktivuje end profile, ked event konci
1. ak event nebol na konci timeline listu, nerobi sa nic - ani nesmie, lebo musi zostat aktivny
   profil, ktory bol aktivovany posledne startnutou udalostou
2. end profile sa moze aktivovat len, ak to udalost dovoli. Napriklad EventPreferencesTime dovoli
   aktivovat end profile len ak ma nastaveny _useEndTime. A toto je zatial jediny typ, kde to
   nie je natvrdo true - TOTO UZ NEPLATI, BOLO TO VYHODENE
3. najprv sa aktivuje _fkProfileEnd, ak je nastaveny a to len ak uz nie je aktivovany
4. potom sa robi undo profile, aktivuje sa _fkProfileEndActivated z prislusneho event timeline
   a to len aku uz nie jej aktivovany
5. ak sa neaktivoval profil v bodoch 3 a 4, updatne sa notifikacia a widgety na aktualne aktivovany
   profil
Vysledkom je, nic sa nezmeni, zostane aktivovane to, co prave aktivovane je. Cize event profil
nedeaktivuje.

Ako sa spustaju, zastavuju eventy v EventsService
a) na restart eventov
   1. najprv sa eventy pauzuju, pauzuju sa aj tie, co uz su zapauzovane, aktivuju sa end profily
   2. potom sa event spustaju, spustaju sa len tie, co este nebezia, ignoruje sa tu, ze profil je
      uz aktivovany, cize sa reaktivuje
   Cize vysledkom je, ze sa postupne vsetky profily aktivuju. Nie je mozne, aby nezostal daky
   profil aktivovany, vid "Ako sa profil aktivuje na start a end eventu".
b) na ostatne systemove udalosti
   1. najprv sa udalosti pauzuju, a to len tie, ktore bezia, aktivuju sa end profily
   2. potom sa udalosti spustaju, a to len tie, ktore este nebezia, aktivuju sa start profily
   Cize vysledkom je, ze sa postupne vsetky profily aktivuju. Nie je mozne, aby nezostal daky
   profil aktivovany, vid "Ako sa profil aktivuje na start a end eventu".

Co sa deje v EventsService po spusteni, pauznuti eventov
a) ak nie je manualne aktivovany profil a uz nebezi ziadna udalost
   1. ak je nastaveny background profil
      1.1 ak aktualne aktivovany profil nie je background profil, aktivuje sa background profil !!!!
      1.2 na restart udalosti sa vzdy aktivuje background profil !!!
      1.3 ak nie je nastaveny background profile, nic sa nedeje, zostane aktivovane, co je
b) ak je manualne aktivovany profil (getEventsBlocked = true a getForceRunEventRunning = false)
   1. aktivuje sa background profil, ale len ak nie je ziaden profil aktivovany
Vysledkom je, ze sa aktivuje background profil, ak nebezi ziadna udalost.
!!! To ale znamena, ze pre EventPreferencesTime, ak nie je endTime, nezostane aktivovany start profil !!!!
Vo vseobecnosti - nie je podpora pre nerozsahove eventy !!!

/* Netreba, zrusil som "Use end profile" z time event preferences a taktiez komplet podporu na
   nerozsahove enety
Co tak spravit pre nerozsahove eventy toto:
1. event sa spusti - nechame ho bezat donekonecna
2. ak sa startne dalsi event, pauzneme vsetky beziace nerozsahove enety
3. potom by sa nestalo, ze by sa aktivoval background profil, ak bezi nerozsahovy event
*/

OK, takze ak nebezi udalost, aktivuje sa background profil ak je nastaveny.

Aha? a co udalost SMS? Ta trva len 5 sekund a hned skonci. Ze by aj tu nebol problem, lebo vsak ide
len o to, aby to (ne)notifikovalo? Asi hej.

----------------------------------------------------

Pridaj do udalosti do "Koniec udalosti" moznost si nastavit "Restart udalosti".
Mame tam:
- "Aktivovat profil"
- "Vrat spat profil"

Pridat "A urobit" ("And do") ako ListPreference  s polozkami:
1. "Nic" (None)
2. "Vratit spat profil"
3. "Restartovat udalosti" (Restart events)

-----------------------------------------------------

Pridat do eventu do "Start event" kategorie checkbox "Aktivuj manualne".
Ta by robila manualnu aktivaciu na start udalosti.
Cize taketo udalosti by nemali "End event" a profil by aktivovali manualne
Ak to bude zaskrtnute, "End event" kategoria sa zakaze
Potom este treba zmenit zobrazovanie, profilu, aby tam bolo aj pre
manualnu aktivaciu, ze ktory event to nastavil.

A pridat do navigation panelu novy filter na One shot eventy (?)

A daj to aj do Activity logu, ze bol spusteny event s manualnou aktivaciou

Problem, je ze mam spraveny mergeProfile.
Musi to teda fungovat tak, ze ak robim merge, ak nadabim na udalost
ktora ma manualnu aktivaciu nastavenu, tak profil nemergnem (nezavolam Profile.mergeProfile()),
ale ho aktivujem manualne a mergedProfile._id nastavim na 0. V EventsService mam test na _id = 0,
cize sa nebude robit aktivacia mergedProfile.

Do Editora dat indikator ku nazvu profilu, ze sa aktivuje manualne: [M]
Nezobrazovat End profil

------------------------------------------------------

1. Bezi udalost Doma a Spanok.
2. Zastrcim sluchatka, spusti sa udalost Diskoteka
3. Necham sluchatka zastrcene a vysuniem ich az po tom, co skonci udalost Spanok
4. Spravi to to, ze bezi uz len udalost Doma, ale zostane aktivny profil Spanok, lebo Diskoteka
   ma "Undo"
5. podla spravnosti ma byt aktivovany profil Doma.
Cize "Undo" by vlastne malo vratit profil udalosti, ktora je ako posledna v timeline.
To sice mam, ale pamatam si profil pri jeho starte.
Musim teda zistovat, profil udalosti v timeline pri jej ukoncovani, nie pri jej starte.

------------------------------------------------------

Napadla ma sialena myslienka.
Kedze viem odchytit, ze zvoni, co tak spravit toto pre oddelenie hlasitosti zvonenia a notifikacii:
1. nastavit najprv zvonenie, potom notifikacie
2. cize hlasitost bude nastavena pre notifikacie
3. viem zachytit, ze zvoni
4. ak zachytim, ze zvoni, nastavim hlasitost zvonenia aj notifikacii na hlasitost zvonenia v profile
5. po ukonceni hovoru nastavim hlasitost zvonenia a notifikacii spat podla profilu

-------------------------------------------------------

Blokovanie udalosti, ak po manualnej aktivacii bezi force run event a znova dam manualnu aktivaciu.

1. Musim vediet, doslo k manualnej aktivacii.
   Na to je priznak PREF_EVENTS_BLOCKED, ktory sa nastavi na true, ak sa manualne
   aktivuje profil. PASSED
2. Ak sa spusti event, testujem PREF_EVENTS_BLOCKED a ak je true, pustim len forceRun event.
   PASSED.
3. Ak znova dojde k manualnej aktivacii profilu, musim zablokovat beziace forceRun eventy. Ziadne
   ine nesmiem blokovat. PASSED
4. Blokovany event nesmiem spustit. PASSED
5. Eventy sa oblokuju restartom udalosti a ked sa event pauzne. Restart moze nastat:
   a) manualne - odblokovat - PASSED
   b) po zmene parametrov udalosti - PASSED
   c) po skonceni trvania profilu - odblokovat - PASSED
   d) po skonceni udalosti - odblokovat - PASSED
   e) na prvy start aplikacie - odblokovat - PASSED

------------------------------------------------------------

Kedy sa odblokovavaju udalosti po restarte
- restartEventsWithAlert
  - vola restartEventsWithRescan
    - vola restartEvents s unblockEventsRun = true
      - vola RestartEventsBroadcastReceiver s unblockEventsRun = true
- ProfileDurationAlarmBroadcastReceiver
  - vola restartEventsWithRescan
    - vola restartEvents s unblockEventsRun = true
      - vola RestartEventsBroadcastReceiver s unblockEventsRun = true
- restartEventsWithRescan
  - vola restartEvents s unblockEventsRun = true
    - - vola RestartEventsBroadcastReceiver s unblockEventsRun = true
- firstStartEvents
  - vola RestartEventsBroadcastReceiver s unblockEventsRun = true
- pauseEvent
  - restartEventsWithDelay s unblockEventsRun = true

Cize udalosti sa odblokuju
1. na manualny restart udalosti (Aktivator, Editor, notifikacia)
2. pri prvom starte aplikacie
3. po vyprsani trvania aktivacie profilu
4. po pauznuti udalosti

Problem nie je ani pri pause eventov po manualnej ativacii profilu. Event.pauseEvent ma na to parameter
allowRestart a ten je pri pauseAllEvents = false.

Kde sa vola GlobalData.setEventsBlocked():

***
- DataWrapper.firstStartEvents() - false (unblock)
  - volane je z EditorProfilesActivity.onOptionsItemSelected() - zapnutie udalosti
  - volane je z FirstStartService.onHandleIntent()
***

***
- DataWrapper.restartEventsWithRescan() - false (unblock)
  - volane z DataWrapper.restartEventsWithAlert()
  - volane z ProfileDurationAlarmBroadcastReceiver() - generovane na konci trvania profilu, ak ma nastaveny rescan
***

***
- DataWrapper.restartEventsWithAlert() - false (unblock)
  - volane z ActivateProfileActivity.onOptionsItemSelected()
  - volane z EditorProfileActivity.onOptionsItemSelected()
  - volane z RestartEventsFromNotificationActivity.onStart()
***

***
- EditorProfilesActivity.doImportData() - false (unblock)
  - volane je z EditorProfilesActivity.importDataAlert()
  - volane je z EditorProfilesActivity.onActivityResult()
***

- RestartEventsBroadcastReceiver.onReceive() - false (unblock) - ak GlobalData.EXTRA_UNBLOCKEVENTSRUN=true
  - volane z DataWrapper.firstStartEvents() - GlobalData.EXTRA_UNBLOCKEVENTSRUN=false
  - volane z DataWrapper.restartEvents () - GlobalData.EXTRA_UNBLOCKEVENTSRUN=false
***  - volane z DataWrapper.restartEventsWithDelay() - GlobalData.EXTRA_UNBLOCKEVENTSRUN=unblockAllEvents

- DataWrapper.restartEventsWithDelay() - parameter unblockEventsRun
  - volane z EditorProfilesActivity.doImportData() - unblockEventsRun=false
***  - volane z Event.doActivateEndProfile() - ak sa ma spravit restart na konci udalosti - unblockEventsRun=true


- DataWrapper.restartEvents() - false (unblock) - ak parameter unblockAllEvents=true
***  - volane je z DataWrapper.restartEventsWithRescan() - unblockAllEvents=true
  - volane je z DataWrapper.stopEventsForProfile() - unblockAllEvents=false
  - volane je z EditorEventListFragment.deleteEvent() - unblockAllEvents=false
  - volane je z EditorEventListFragment.runStopEvent() - unblockAllEvents=false
  - volane je z EventPreferencesFragment.savePreferences() - unblockAllEvents=false

- DataWrapper.pauseAllEvents() - parameter
  - volane je z DataWrapper._activateProfile() - true (block)
***  - volane je z EditorProfilesActivity.onOptionsItemSelected() - false (unblock) - vypnutie udalosti

--------------------------------------------------------------------

Oddelenie zvonenia a notifikacii:
- Teraz testujem audiomanager ringermode. Ak je NORMAL, tak robim unlink
- Problem ale bude s Interruptions. Podla mna by som mal zistovat aj to, aky interruption filter je nastaveny.
  Da sa to uplne jednoducho a to cez Settings.Global.getInt("zen_mode")
- Cize, pre Lollipop by som mal robit unlink ak: interruptions filter nie je NONE a zaroven je audiomanager ringermode = NORMAL

--------------------------------------------------------------------

Startery:
- pride udalost, napr SMS alebo notifikacia
- zavolat EventsService
  - pre SMS zavolat z SMSBroadcastReceiver - do intentu dat kontakt a cas
  - pre notifikace zavolat z NotificationBroadcastReceiver - do intentu dat package a cas
- v EventsService prechadzat vsetky eventy
  - ak ma event zapnute smsky, a kontankt sedi, zapisat do eventu cas
  - ak ma event zapnute notifikacie a package sedi, zapisat do eventu cas
- potom standardne spustat eventy
- v doEventService sa vezme startTime eventu prida sa duration a zisti sa ci je aktualny cas v rozsahu

--------------------------------------------------------------------

Android M

1. Wifi scanning dako divno funguje. Ide, ale so strasnym intervalom. Hadam bude opravene exact alarmom - nakodene, testujem
2. Doze mod: funguje ako Sony Stamina mod. Je tiez mozne nastavit vynimku. Aj tak divno funguje, je mozne ze suvisi s tymi alarmami, vid bod 2.
3. Na Exit aplikaciu vznikne exception. Leak viewu. Na G2 to nerobi, zatial predpokladam, ze ide o bug v Android M.
4. Nove veci: Doze (setrenie baterie), Security (uzivatek urcuje, co moze aplikacia), Data do cloudu (zaloha dat apliakcie)

---- Security:

PROFILY
- spravme tak, ze bude zdruzovat podla profilu/udalosti
- kazdy profil/udalost maju prefernces, cize spriahnut preference so zoznamom privilegii
- pri aktivacii profilu skontrolujeme vsetky nastavene preferences a k nim privilegia
- ak nebudu vsetky povolene, profil neaktivujeme
- ak aktivujeme profil manualne z Aktivatora/Editora (profil moze byt aktivovany manualne, aj ked nie z gui),
  vypytame si povolenie privilegii cez dialog
- ak neaktivujeme z gui, vytvorime o tom notifikaciu, klik na nu vyvola dialog na povolenie privilegii
- po potvrdeni privilegii profil neaktivujeme, ale updatneme widgety a notifikaciu, aktivity zavrieme
- ak privilegia nebudu potvrdene, nerobime nic
- ak bude niektore natvrdo zakazane, nerobime dialog/notifikaciu o tom
- phone - mam len broadcast receiver. Ten nefunguje, ak nemam povolene Phone skupinu:
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" />
  Cize aplikacia nespadne ani pri prichodzom, ani pri odchodzom hovore.

EVENTY
- Pre eventy sa vyvola notifikacia na grant. Vyvola sa z DataWrapper.doEventService().
- Povodne som chcel testovat aj privilegia profilov v evente. Tu je problem, ze sa v EventsService profily merguju.
  Cize ak by som dal notifikaciu na grant s mergeProfiles=true sa moze stat, ze v merge tabulke uz bude iny stav.
- Takze grant na eventy bude bez checku profilov.
- Este je iny zdroj, kedy sa event pauzuje/stopuje. Tieto zdroje priamo volaju pauseEvent(), stopEvent().
  Tie ale nemerguju profily.
- Profily si sami nahodia notifikaciu na grant, lebo EventsService, DataWrapper.doEventService(), startEvent(),
  pauseEvent(), stopEvent() zavola activateProfileFromEvent() a tam sa generuje notifikacia.
- Ak uzivatel grantnem tak sa restartnu udalosti, ale nerusit manualne aktivovany profil.

CO ESTE TREBA
- Skus, ci existuje broadcast na zmenu permissions. Tu by sa dali zrusit permission notifikacie a updatnut
  profil notifikacia a widgety

CO FUNGUJE CIASTOCNE:
- wifi scanning aby fungoval aj na pozadi je ntune:
  - musi byt zapnuta lokacia
  - musi byt povolene scanovanie wifi v nastaveniach lokacie
- bluetooth scanning - classic je ok, nemusi byt lokacia zapnuta
- bluetooth scanning - LE - neviem, ci treba:
  - musi byt zapnuta lokacia
  - musi byt povolene scanovanie bluetooth v nastaveniach lokacie
  - treba testnut, ale nemam LS zariadenie :-(
- Settings.System.putFloat(_context.getContentResolver(), "screen_auto_brightness_adj", value); hadze to exception:
  "java.lang.IllegalArgumentException: You cannot change private secure settings."
  - "Vyriesene" rootom.
- Settings.System.putInt(context.getContentResolver(), Settings.System.VIBRATE_WHEN_RINGING, 0); hadze to exception:
  "java.lang.IllegalArgumentException: You cannot change private secure settings."
  - "Vyriesene" rootom.

---- Power management:

1. Ak je device v "Device Idle" mode, podla dokumentacie nerobi wifi scanning.
2. Pocas "device idle" nerobit scanning, odchytavat broadcast na zmenu modu a ak sa
   "Device Idle" vypne, zavolat EventsService (akoby to bol typ udalosti).
3. Aplikacia sa moze dostat do "App Standby" modu. Treba zistit, ako sa toto da odchytit. Ak bude v tomto mode,
   scannovat s intervalom raz tak dlhym ako je prednastavene. Ak sa vypne tento mod, spravit one scan.
4. Od Lollipopa existuje "Power Save" mod. Da sa odchytit boradcast. Mal by fungovat tak ako pri
   "App standby" mode.

-------

--- Poznamky z Notable:

1. scanning - ak bezi, a dam spustit one shot scanning z preferences, neukoncit hned, ale cakat na
   ukoncenie beziaceho
2. sprav udalost na start aplikacie
3. skus spravit do profilu moznot zastavit aplikaciu
4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

---------------------------------------------------------------------------

---------- Lokacia -----------------------------

Vsetko uz mam, geofences mam v tabulke, preference dialog spraveny, teraz uz treba len
zacat skenovat, co som v radiuse geofence.

Na FirstStartEvents() spojim sa s GoogleAPI. Potom dam zistenie, ci nejake udalosti mam na lokaciu
a ak ano, nastavim vsetko co treba (vid dokumentacia).

Na globalne zastavenie udalosti a Exit, zrusim GoogleAPI spojenie (vid dokumentacia).

Na pause udalosti s lokaciou:
- ak je event povoleny: pridam jeho geofence na skenovanie.
- inac: vyhodim ho zo skenovania.

----------------------------------------------


- Aktivator/Editor/Widget- nezmesti sa nazov profilu, zavadzia ta kvacka tam
- Tlacitka Zrusit/OK - na Android 4.1 maju tenke pismo, ale MaterialDialog to ma OK


-------------------------------------------------

    public static int o(Context context)
    {
        return ((TelephonyManager)context.getSystemService("phone")).getPhoneType();
    }

    public static int[] q(Context context)
    {
        int ai[] = new int[7];
        int[] _tmp = ai;
        ai[0] = 0;
        ai[1] = 1;
        ai[2] = 2;
        ai[3] = 3;
        ai[4] = 9;
        ai[5] = 11;
        ai[6] = 12;
        int ai1[] = new int[5];
        int[] _tmp1 = ai1;
        ai1[0] = 4;
        ai1[1] = 5;
        ai1[2] = 6;
        ai1[3] = 8;
        ai1[4] = 11;
        int i1 = o(context);
        if (i1 == 1)
        {
            return ai;
        }
        if (i1 == 2)
        {
            return ai1;
        } else
        {
            int j1 = ai.length;
            int k1 = ai1.length;
            context = new int[j1 + k1];
            System.arraycopy(ai, 0, context, 0, j1);
            System.arraycopy(ai1, 0, context, j1, k1);
            return context;
        }
    }

    public static String a(int i1, boolean flag)
    {
        switch (i1)
        {
        default:
            return "Unknown";

        case 0: // '\0'
            if (flag)
            {
                return "3G/2G";
            } else
            {
                return "3G/2G - WCDMA/GSM (WCDMA preferred)";
            }

        case 1: // '\001'
            if (flag)
            {
                return "2G";
            } else
            {
                return "2G - GSM";
            }

        case 2: // '\002'
            if (flag)
            {
                return "3G";
            } else
            {
                return "3G - WCDMA";
            }

        case 3: // '\003'
            if (flag)
            {
                return "2G/3G";
            } else
            {
                return "2G/3G - GSM/WCDMA (auto)";
            }

        case 4: // '\004'
            if (flag)
            {
                return "2G/3G";
            } else
            {
                return "2G/3G - CDMA, EvDo";
            }

        case 5: // '\005'
            if (flag)
            {
                return "2G";
            } else
            {
                return "2G - CDMA";
            }

        case 6: // '\006'
            if (flag)
            {
                return "3G";
            } else
            {
                return "3G - EvDo";
            }

        case 7: // '\007'
            if (flag)
            {
                return "2G/3G";
            } else
            {
                return "2G/3G - GSM/WCDMA, CDMA, EvDo";
            }

        case 8: // '\b'
            if (flag)
            {
                return "2G/3G/4G";
            } else
            {
                return "2G/3G/4G - CDMA, EvDo, LTE";
            }

        case 9: // '\t'
            if (flag)
            {
                return "2G/3G/4G";
            } else
            {
                return "2G/3G/4G - GSM/WCDMA, LTE";
            }

        case 10: // '\n'
            if (flag)
            {
                return "2G/3G/4G";
            } else
            {
                return "2G/3G/4G - GSM/WCDMA, CDMA, EvDo, LTE";
            }

        case 11: // '\013'
            if (flag)
            {
                return "4G";
            } else
            {
                return "4G - LTE";
            }

        case 12: // '\f'
            break;
        }
        if (flag)
        {
            return "3G/4G";
        } else
        {
            return "3G/4G - WCDMA/LTE";
        }
    }


--------------------------------

Link/ulink + simuacia nocneho hovoru

1. ringer mod a hlasitosti + link/unlink treba robit vzdy, ak aktivujem profil
2. ak neaktivujem, robim len link/unlink
3. simulaciu robim, ak aktivacia profilu zmeni ringer mod alebo ton zvonenia
Toto mam.

Problem je prioritny mod. Ten hned po restarte nezvoni (ak nemam kontakt vo vynimkach),
ale dalsie hovory zvonia vzdy, je jedno kto vola.
Skus si pozriet ringer mod priamo z audio managera, ze aky je. Ja by som nemenil hlasitosti,
ak tento bude vibrate a silent. Mozno to zafunguje aj na zen mody. Testni to aj na android 5.

